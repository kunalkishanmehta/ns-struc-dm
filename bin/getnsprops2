#!/usr/bin/python
__doc__ = 'GETNSPROPS -- calculate NS properties as a function of central density for selected EoSs'
__usage__ = 'getnsprops EoS1.csv,EoS2.csv,... [-v] [-p R,M,Lambda,...] [-n 200] [-r 0.8,12] [-d ./eos/] [-o ./dat/]'
__author__ = 'philippe.landry@ligo.org'
__date__ = '03-2019'

import numpy as np
from optparse import OptionParser
from scipy.interpolate import interp1d
from nsstruc.tov import tov
from nsstruc.constants import *
import scipy.interpolate
from scipy.optimize import curve_fit
from scipy.interpolate import interp1d
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import h5py
# import pandas as pd
# from nsstruc.pltsetup import *


parser = OptionParser(usage=__usage__, description=__doc__)
parser.add_option('-p', '--props', default='R,M,Lambda', help='comma-separated list of NS properties to calculate, DEFAULT=R,M,Lambda', metavar='R,M,Lambda')
parser.add_option('-n', '--numrhoc', default=2e2, help='number of central densities to sample per EoS, DEFAULT=200', metavar='2e2')
parser.add_option('-r', '--rhorng', default='0.8,1.2e1', help='comma-separated min and max values for central density in units of rhonuc, DEFAULT=0.8,1.2e1', metavar='0.8,1.2e1')
parser.add_option('-R', '--rhodmrng', default='0.8,1.2e1', help='comma-separated min and max values for central dark matter density in units of rhonuc, DEFAULT=0.8,1.2e1', metavar='0.8,1.2e1')
parser.add_option('-s', '--stpi', default=1e1, help='starting step size for radial TOV integration in cm, DEFAULT=1e1', metavar='1e1')
parser.add_option('-N', '--numpts', default=2e3, help='number of points for radial TOV integration, DEFAULT=2e3', metavar='2e3')
parser.add_option('-m', '--maxr', default=2e6, help='radius endpoint in cm for surface finding algorithm, DEFAULT=2e6', metavar='2e6')
parser.add_option('-T', '--tol', default=1e1, help='pressure tolerance for surface finding algorithm in g/cm^3, DEFAULT=1e1', metavar='1e1')
parser.add_option('-d', '--dir', default='./eos/', help='path to directory housing EoS data, DEFAULT=./eos/', metavar='./eos/')
parser.add_option('-o', '--outdir', default='./dat/', help='path to output directory, DEFAULT=./dat/', metavar='./dat/')
parser.add_option('-t', '--tag', default='macro-', help='tag for output data file, DEFAULT=macro-', metavar='macro-')
parser.add_option('-v', '--verbose', action='store_true', default=False, help='toggle verbose output, DEFAULT=False', metavar='False')

opts, args = parser.parse_args()
eosnames = str(args[0]).split(',')
props = str(opts.props).split(',')
numprops = len(props)
rhorng = str(opts.rhorng).split(',')
rhodmrng = str(opts.rhodmrng).split(',')

if len(rhorng) >2:
	rhocord = [float(rho) for rho in rhorng]
else:
	rhoi, rhof = [float(rho) for rho in rhorng]

if len(rhodmrng) >2:
	rhodmcord = [float(rho) for rho in rhodmrng]
else:
	rhodmi, rhodmf = [float(rho) for rho in rhodmrng]
numrhoc = int(float(opts.numrhoc))
stp = float(opts.stpi)
numpts = int(float(opts.numpts))
maxr = float(opts.maxr)
tol = float(opts.tol)
indir = str(opts.dir)
outdir = str(opts.outdir)
tag = str(opts.tag)
verb = opts.verbose

# CALCULATE NS PROPERTIES FOR EACH EOS

# def Solver(eos,props = 'R,M,Lambda'):
	
for eosname in eosnames:

	shortname = (eosname.split('.')[0]).split('eos-')[-1]
	if verb == True: print('Calculate properties of ' + str(shortname) + ' stars')

	eospath = indir+eosname
# 	eospath2 = str(eos)
	outfile = open(outdir+tag+shortname+".csv","w")
	outfile.write('rhoc,rhocdm,' + ','.join(props) + ',Mg,fdm \n')

	eosdat = np.genfromtxt(eospath,names=True,delimiter=',')
	rhodat = eosdat['baryon_density'] # rest-mass energy density in units of g/cm^3
	pdat = eosdat['pressurec2'] # pressure in units of g/cm^3
	mudat = eosdat['energy_densityc2'] # total energy density in units of g/cm^3

	rhop = interp1d(pdat,rhodat,kind='linear',bounds_error=False,fill_value=0)
	def Rho(p): return rhop(p)

	mup = interp1d(pdat,mudat,kind='linear',bounds_error=False,fill_value=0)
	def mu(p): return mup(p)

	prho = interp1d(rhodat,pdat,kind='linear',bounds_error=False,fill_value=0)
	def P(rho): return prho(rho)

	cs2pi = interp1d(pdat,np.gradient(mudat,pdat),kind='linear', bounds_error=False, fill_value=0)
	def cs2i(p): return cs2pi(p) # 1/sound speed squared
	if len(rhorng) >2:
		rhocs = rhocord
		properties = np.zeros((len(rhorng), numprops+4))
	else:
		rhocs = np.linspace(max(rhoi*rhonuc,rhodat[0]),min(rhof*rhonuc,rhodat[-1]),numrhoc)
		properties = np.zeros((numrhoc**2, numprops+4))
	if len(rhodmrng) >2:
		rhocdms = rhodmcord
		properties = np.zeros((len(rhodmrng), numprops+4))
	else:
		rhocdms = np.linspace(max(rhodmi*rhonuc,rhodat[0]),min(rhodmf*rhonuc,rhodat[-1]),numrhoc)
		properties = np.zeros((numrhoc**2, numprops+4))


	i = 0
	if verb == True: print('Start at central density {0} g/cm^3'.format(rhocs[0]))

	if len(rhorng) >2:
		for rhoc,rhocdm in zip(rhocs,rhocdms): # compute macroscopic properties for star of each central density
			macro = tov([mu,P,cs2i,Rho],rhoc, rhocdm, props,stp,numpts,maxr,tol)
			properties[i] = [item for List in [[rhoc],[rhocdm],macro] for item in List] + [macro[props.index('Mdm')]+macro[props.index('M')],macro[props.index('Md')]/(macro[props.index('Mb')]+macro[props.index('Md')])]      
			i = i+1
	else:
		for rhoc in rhocs: # compute macroscopic properties for star of each central density
			for rhocdm in rhocdms:
				macro = tov([mu,P,cs2i,Rho],rhoc, rhocdm, props,stp,numpts,maxr,tol)
				properties[i] = [item for List in [[rhoc],[rhocdm],macro] for item in List] + [macro[props.index('Mdm')]+macro[props.index('M')],macro[props.index('Md')]/(macro[props.index('Mb')]+macro[props.index('Md')])]      
				i = i+1

	if verb == True: print 'Done at central density {0} g/cm^3\nSave to '.format(rhocs[-1])+outdir+tag+shortname+'.csv'

	np.savetxt(outfile,properties,delimiter=',')
# 	header = ['rhoc', 'rhocdm', 'R', 'M', 'Rdm','Mdm','Mb', 'Md', 'Mg', 'fdm' ]
# 	properties2 = pd.DataFrame(properties, columns = header)
	
	headers = ('rhoc,rhocdm,'+','.join(props) + ',Mg,fdm').split(',')
	#properties[headers.index('rhoc')]
		   


# to associate the dark matter fraction to each point in rhoc-rhocdm space, interpolate 3D (rhoc,rhocdm,fdm) data to get a function fdm(rhoc,rhocdm)
x = properties[:, headers.index('R')]  # Input data from 'R' column
y = properties[:, headers.index('rhocdm')]  # Input data from 'rhocdm' column
z = properties[:, headers.index('fdm')]  # Input data from 'fdm' column

X = np.linspace(0.1e14,3.1e15,1000) # the grid where we'll evaluate fdm(rhoc,rhocdm)
Y = np.linspace(0.1e14,3.1e15,1000)
x_grid, y_grid = np.meshgrid(X, Y)

outdat = scipy.interpolate.griddata((x,y),z,(x_grid,y_grid),'linear')
#  # fdm evaluated on the grid, with one of three methods: nearest, linear, cubic

num_cs = 9
contour_fdm = list(np.geomspace(1e-2, 0.1, 2)) + list(np.linspace(0.1, 0.9, num_cs)[1:]) + list(reversed(1. - np.geomspace(1e-2, 0.1, 2)[:-1]))

cs = plt.contour(x_grid, y_grid, outdat, contour_fdm, colors='r')  # plot the contours of constant fdm(rhoc, rhocdm)
# plt.scatter(x, y, marker='.', s=3)  # overlay the rhoc-rhocdm scatter points for comparison

plt.xlabel('rho_c [g/cm^3]')
plt.ylabel('rho_c^DM [g/cm^3]')

# Save the plot as an image file
plt.savefig('plot.png')


contours = []
for i in range(num_cs+3):
  try: c = cs.allsegs[i][0] # if a contour was plotted, save it
  except: continue
  contours += [c] # list that stores all the extracted contours

# downsample the contours to get a list of (rhoc,rhocdm) coordinates to use to generate a constant-fdm sequence of stars

num_stars = 100 # how many stars to aim for in the sequence
rhocs, rhocdms = [], []


for c in contours:
    skip = int(len(c[:,0])/num_stars)
    if skip == 0:
        print("Skip value is zero. Skipping contour:", c)
        continue
    rhocs += [c[::skip,0]]
    rhocdms += [c[::skip,1]]


# for c in contours:
  
#   skip = int(len(c[:,0])/num_stars)
#   print("Skip:", skip)
#   rhocs += [c[::skip,0]]
#   rhocdms += [c[::skip,1]] # downselect to num_stars (rhoc,rhocdm) points


rhomin = 2.8e14 # because some central densities are too small to give physical neutron stars, throw out those below rhomin
rhomax = 12*rhomin # because some central densities are too large to give physical neutron stars, throw out those above rhomax
rhocs_out, rhocdms_out = [], []

for c,cdm in zip(rhocs,rhocdms):
  c_out, cdm_out = [], []

  for rhoc,rhocdm in zip(c,cdm):
    
    if (rhoc >= rhomin or rhocdm >= rhomin) and rhoc <= rhomax and rhocdm <=rhomax: # one of rhoc/rhocdm below rhomin is ok, to allow pure regular matter or pure dm star
      c_out += [rhoc]
      cdm_out += [rhocdm]
  rhocs_out += [c_out]
  rhocdms_out += [cdm_out]

def find_rhos(n):
  newrhoc = [str(r) for r in rhocs_out[n]]
  find_rhos.newrhocs_list = ','.join(newrhoc)

  newrhocdm = [str(r) for r in rhocdms_out[n]]
  find_rhos.newrhocdms_list = ','.join(newrhocdm)
  return find_rhos.newrhocs_list, find_rhos.newrhocdms_list

dict_properties = {}

for i in range(num_cs+3):
	print('i=', i)
	newrhocslist, newrhocdmlist = find_rhos(i)

	newproperties = np.zeros((len(newrhocslist), numprops+4))
	for rhoc in newrhocslist: # compute macroscopic properties for star of each central density
		for rhocdm in newrhocdmlist:
			macro = tov([mu,P,cs2i,Rho],rhoc, rhocdm, props,stp,numpts,maxr,tol)
			newproperties[i] = [item for List in [[rhoc],[rhocdm],macro] for item in List] + [macro[props.index('Mdm')]+macro[props.index('M')],macro[props.index('Md')]/(macro[props.index('Mb')]+macro[props.index('Md')])]      
			i = i+1
	dict_properties[contour_fdm[i]] = newproperties


# to associate the (dark) baryon mass to each point in rhoc-rhocdm space, interpolate 3D (rhoc,rhocdm,Mb) data to get a function Mb(rhoc,rhocdm)

x = properties[:, headers.index('R')]  # Input data from 'R' column
y = properties[:, headers.index('rhocdm')]  # Input data from 'rhocdm' column
z = properties[:, headers.index('Mb')]  # Input data from 'Mb' column
zdm = properties[:, headers.index('Md')]  # Input data from 'Md' column

X = np.linspace(0.1e14,3.1e15,1000) # the grid where we'll evaluate Mb(rhoc,rhocdm)
Y = np.linspace(0.1e14,3.1e15,1000)
x_grid, y_grid = np.meshgrid(X, Y)

outdat = scipy.interpolate.griddata((x,y),z,(x_grid,y_grid),'linear') # Mb evaluated on the grid, with one of three methods: nearest, linear, cubic
outdat_dm = scipy.interpolate.griddata((x,y),zdm,(x_grid,y_grid),'linear') # Md evaluated on the grid

# plot the interpolated Mb and Md functions

plt.pcolormesh(x_grid,y_grid,outdat,cmap='gray_r') # show Mb(rhoc,rhocdm) as a color map (darker = larger Mb)
#plt.pcolormesh(x_grid,y_grid,outdat,cmap='gray_r') # show Md(rhoc,rhocdm) as a color map (darker = larger Mb) -- but can't seem to show two colormaps at once

num_cs = 11
cs = plt.contour(x_grid,y_grid,outdat,list(np.linspace(1.,3.,num_cs)),colors='r') # plot the contours of constant Mb(rhoc,rhocdm)
cs_dm = plt.contour(x_grid,y_grid,outdat_dm,list(np.linspace(1.,3.,num_cs)),colors='g') # plot the contours of constant Md(rhoc,rhocdm)

# extract the (rhoc,rhocdm) coordinates of the constant-fdm contours

contours = []
for i in range(num_cs+3):
  try: c = cs.allsegs[i][0] # if a contour was plotted, save it
  except: continue
  contours += [c] # list that stores all the extracted contours

# downsample the contours to get a list of (rhoc,rhocdm) coordinates to use to generate a constant-fdm sequence of stars

num_stars = 100 # how many stars to aim for in the sequence
rhocs, rhocdms = [], []

for c in contours:
  
  skip = int(len(c[:,0])/num_stars)
  rhocs += [c[::skip,0]]
  rhocdms += [c[::skip,1]] # downselect to num_stars (rhoc,rhocdm) points


rhomin = 2.8e14 # because some central densities are too small to give physical neutron stars, throw out those below rhomin
rhomax = 12*rhomin # because some central densities are too large to give physical neutron stars, throw out those above rhomax
rhocs_out, rhocdms_out = [], []

for c,cdm in zip(rhocs,rhocdms):
  c_out, cdm_out = [], []

  for rhoc,rhocdm in zip(c,cdm):
    
    if (rhoc >= rhomin or rhocdm >= rhomin) and rhoc <= rhomax and rhocdm <=rhomax: # one of rhoc/rhocdm below rhomin is ok, to allow pure regular matter or pure dm star
      c_out += [rhoc]
      cdm_out += [rhocdm]
  rhocs_out += [c_out]
  rhocdms_out += [cdm_out]

# plot the interpolated Mb and Md functions

plt.pcolormesh(x_grid,y_grid,outdat,cmap='gray_r') # show Mb(rhoc,rhocdm) as a color map (darker = larger Mb)
#plt.pcolormesh(x_grid,y_grid,outdat,cmap='gray_r') # show Md(rhoc,rhocdm) as a color map (darker = larger Mb) -- but can't seem to show two colormaps at once

num_cs = 11
# cs = plt.contour(x_grid,y_grid,outdat,list(np.linspace(1.,3.,num_cs)),colors='r') # plot the contours of constant Mb(rhoc,rhocdm)
cs_dm = plt.contour(x_grid,y_grid,outdat_dm,list(np.linspace(1.,3.,num_cs)),colors='g') # plot the contours of constant Md(rhoc,rhocdm)

contours_dm = []
for i in range(num_cs+1):
  try: c = cs_dm.allsegs[i][0] # if a contour was plotted, save it
  except: continue
  contours_dm += [c] # list that stores all the extracted contours

# downsample the contours to get a list of (rhoc,rhocdm) coordinates to use to generate a constant-fdm sequence of stars

num_stars = 100 # how many stars to aim for in the sequence
rhocs, rhocdms = [], []

for c in contours_dm:
  
  skip = int(len(c[:,0])/num_stars)
  rhocs += [c[::skip,0]]
  rhocdms += [c[::skip,1]] # downselect to num_stars (rhoc,rhocdm) points


rhomin = 2.8e14 # because some central densities are too small to give physical neutron stars, throw out those below rhomin
rhomax = 12*rhomin # because some central densities are too large to give physical neutron stars, throw out those above rhomax
rhocs_out, rhocdms_out = [], []

for c,cdm in zip(rhocs,rhocdms):
  c_out, cdm_out = [], []

  for rhoc,rhocdm in zip(c,cdm):
    
    if (rhoc >= rhomin or rhocdm >= rhomin) and rhoc <= rhomax and rhocdm <=rhomax: # one of rhoc/rhocdm below rhomin is ok, to allow pure regular matter or pure dm star
      c_out += [rhoc]
      cdm_out += [rhocdm]
  rhocs_out += [c_out]
  rhocdms_out += [cdm_out]


def find_max(file):
  l = np.argmax((file['Mg']))
  R, M, rho_c, rho_cdm = file['R'][l], file['Mg'][l], file['rhoc'][l], file['rhocdm'][l]
  return R,M, rho_c, rho_cdm

for i in range(num_cs+3):
	print('i=', i)
	newrhocslist, newrhocdmlist = find_rhos(i)

	newproperties = np.zeros((len(newrhocslist), numprops+4))
	for rhoc in newrhocslist: # compute macroscopic properties for star of each central density
		for rhocdm in newrhocdmlist:
			macro = tov([mu,P,cs2i,Rho],rhoc, rhocdm, props,stp,numpts,maxr,tol)
			newproperties[i] = [item for List in [[rhoc],[rhocdm],macro] for item in List] + [macro[props.index('Mdm')]+macro[props.index('M')],macro[props.index('Md')]/(macro[props.index('Mb')]+macro[props.index('Md')])]      
			i = i+1
	dict_properties[contour_mb[i]] = newproperties

contours_dm = []
for i in range(num_cs+1):
  try: c = cs_dm.allsegs[i][0] # if a contour was plotted, save it
  except: continue
  contours_dm += [c] # list that stores all the extracted contours

for c_dm in contours_dm: plt.plot(c_dm[:,0],c_dm[:,1],color='g') # plot the extracted contours

plt.scatter(dat['rhoc'],dat['rhocdm'],marker='.',s=3,c='k') # overlay scatter points

plt.xlabel('rho_c [g/cm^3]')
plt.ylabel('rho_c^DM [g/cm^3]')


# downsample the contours to get a list of (rhoc,rhocdm) coordinates to use to generate a constant-fdm sequence of stars

num_stars = 100 # how many stars to aim for in the sequence
rhocs, rhocdms = [], []

for c in contours_dm:
  
  skip = int(len(c[:,0])/num_stars)
  rhocs += [c[::skip,0]]
  rhocdms += [c[::skip,1]] # downselect to num_stars (rhoc,rhocdm) points


rhomin = 2.8e14 # because some central densities are too small to give physical neutron stars, throw out those below rhomin
rhomax = 12*rhomin # because some central densities are too large to give physical neutron stars, throw out those above rhomax
rhocs_out, rhocdms_out = [], []

for c,cdm in zip(rhocs,rhocdms):
  c_out, cdm_out = [], []

  for rhoc,rhocdm in zip(c,cdm):
    
    if (rhoc >= rhomin or rhocdm >= rhomin) and rhoc <= rhomax and rhocdm <=rhomax: # one of rhoc/rhocdm below rhomin is ok, to allow pure regular matter or pure dm star
      c_out += [rhoc]
      cdm_out += [rhocdm]
  rhocs_out += [c_out]
  rhocdms_out += [cdm_out]

#run the TOV solver on the constant md curves
for i in range(num_cs+3):
	print('i=', i)
	newrhocslist, newrhocdmlist = find_rhos(i)

	newproperties = np.zeros((len(newrhocslist), numprops+4))
	for rhoc in newrhocslist: # compute macroscopic properties for star of each central density
		for rhocdm in newrhocdmlist:
			macro = tov([mu,P,cs2i,Rho],rhoc, rhocdm, props,stp,numpts,maxr,tol)
			newproperties[i] = [item for List in [[rhoc],[rhocdm],macro] for item in List] + [macro[props.index('Mdm')]+macro[props.index('M')],macro[props.index('Md')]/(macro[props.index('Mb')]+macro[props.index('Md')])]      
			i = i+1
	dict_properties[contour_md[i]] = newproperties



		
hf = h5py.File('dict_properties.h5', 'w')
hf.create_dataset('dataset_prop', data=dict_properties)
hf.close()
# Print a message confirming the dataset creation and file path
print('Dataset created successfully!')
print('Dataset saved to: dict_properties.h5')
